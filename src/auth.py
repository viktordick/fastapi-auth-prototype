import inspect
from functools import wraps
from typing import Annotated, Callable, Optional, TypeVar

from fastapi import Depends, HTTPException, Response, status
from fastapi.security import APIKeyCookie, APIKeyHeader
from pydantic import BaseModel
from sqlalchemy.exc import NoResultFound
from sqlmodel import not_, or_, select
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse
from starlette.types import ASGIApp

from .dbsession import DBSession
from .model import (
    AppGroup,
    AppPerm,
    AppPermXGroup,
    AppUser,
    AppUserKey,
    AppUserLogin,
    AppUserXPerm,
)

COOKIE = "__user_cookie"

LoginCookieDep = Annotated[
    str,
    Depends(
        APIKeyCookie(name=COOKIE, description="Generated by /login", auto_error=False)
    ),
]
ApikeyHeaderDep = Annotated[
    str,
    Depends(APIKeyHeader(name="Authorization", auto_error=False)),
]


class User(BaseModel):
    """
    Authentication information for the current user
    """

    name: str
    roles: list[str]


def _auth_apikey(session: DBSession, key: str) -> Optional[AppUser]:
    """
    Split provided Apikey on first dash. The first part is an identifier so we only
    check keys in the database that have the same initial part.
    The rest is checked against the hashed value in the database.
    """
    if not key.startswith("Apikey "):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authorization header",
        )
    return AppUserKey.find(session, key.split()[1])


def _auth_cookie(
    session: DBSession, cookie: str, response: Response
) -> Optional[AppUser]:
    """
    Compare user cookie against appuserlogin_cookie and appuserlogin_nextcookie.
    If the user sent nextcookie, rotate them (assuming that from now on the old
    cookie will no longer be sent). In any case, set the cookie to be used in
    the future in the response (there was something about browsers sometimes no
    longer sending a cookie if we don't remind them with every request that
    this cookie is to be set).
    """
    try:
        login, user = session.exec(
            select(AppUserLogin, AppUser)
            .where(
                or_(
                    AppUserLogin.cookie == cookie,
                    AppUserLogin.nextcookie == cookie,
                ),
                not_(AppUserLogin.done),
            )
            .where(AppUserLogin.appuser_id == AppUser.id)
        ).one()
    except NoResultFound:
        return None

    send_cookie = login.nextcookie or login.cookie
    if cookie == login.nextcookie:
        login.cookie = login.nextcookie
        login.nextcookie = None

    response.set_cookie(
        key=COOKIE,
        value=send_cookie,
        httponly=True,
        secure=True,
        samesite="strict",
    )
    return user


def _process_auth(
    session: DBSession,
    cookie: LoginCookieDep,
    response: Response,
    apikey: ApikeyHeaderDep,
) -> Optional[User]:
    """
    Process authorization at the beginning of (essentially) every request.
    (If a path does not depend on Auth, it is accessible anonymously)
    """
    appuser = None
    if apikey is not None:
        appuser = _auth_apikey(session, apikey)
    elif cookie is not None:
        appuser = _auth_cookie(session, cookie, response)

    if appuser:
        user = User(
            name=appuser.name,
            roles=[
                role.zoperole
                for role in session.exec(
                    select(AppGroup)
                    .join(AppPermXGroup)
                    .join(AppPerm)
                    .join(AppUserXPerm)
                    .where(AppUserXPerm.appuser_id == appuser.id)
                )
            ],
        )
    # We commit here, so the authentication phase and the payload phase are
    # done in separate transactions.
    session.commit()
    return user


Auth = Annotated[Optional[User], Depends(_process_auth)]


_F = TypeVar("_F", bound=Callable[..., object])


def require_roles(*scopes: str) -> Callable[[_F], _F]:
    """
    Decorator to check for given roles
    """

    def require_scopes(required_scopes: tuple[str, ...]):

        def checker(user: Auth):
            # Check if all required scopes are present
            roles = set() if user is None else user.roles
            missing = set(required_scopes) - set(roles)
            if missing:
                raise HTTPException(
                    status_code=403,
                    detail=f"Missing required permissions: {', '.join(missing)}",
                )

            return True

        return checker

    dep = Depends(require_scopes(scopes))

    def decorator(func: _F) -> _F:
        sig = inspect.signature(func)

        # create a new parameter for the dependency (keyword-only)
        dep_param = inspect.Parameter(
            "scope_check",
            kind=inspect.Parameter.KEYWORD_ONLY,
            annotation=Annotated[None, dep],
        )

        # build new signature: keep original params, append dep_param
        params = list(sig.parameters.values()) + [dep_param]
        new_sig = sig.replace(parameters=params)

        @wraps(func)
        async def wrapper(*args, **kwargs):
            # remove scope_check if present before calling original func
            kwargs.pop("scope_check", None)
            return await func(*args, **kwargs)

        # attach the new signature so FastAPI sees the dependency
        wrapper.__signature__ = new_sig  # type: ignore
        return wrapper  # type: ignore

    return decorator


class SameSitePostMiddleware(BaseHTTPMiddleware):
    """
    Rejects all POST or PUT requests that do not include a valid Sec-Fetch-Site header.
    Allowed values: "same-origin"
    """

    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request, call_next):
        if request.method in ("POST", "PUT"):
            sec_fetch_site = request.headers.get("sec-fetch-site")

            if sec_fetch_site != "same-origin":
                return JSONResponse(
                    status_code=401,
                    content={"detail": f"Unauthorized: cross-site {request.method}"},
                )

        return await call_next(request)
