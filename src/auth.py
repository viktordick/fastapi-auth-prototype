import inspect
from functools import wraps
from typing import Annotated, Callable, Optional, TypeVar

from fastapi import Depends, HTTPException, Response
from fastapi.security import APIKeyCookie
from pydantic import BaseModel
from sqlmodel import not_, or_, select
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.responses import JSONResponse
from starlette.types import ASGIApp

from .dbsession import DBSession
from .model import AppGroup, AppPerm, AppPermXGroup, AppUserLogin, AppUserXPerm

COOKIE = "__user_cookie"

LoginCookieDep = Annotated[
    str,
    Depends(
        APIKeyCookie(name=COOKIE, description="Generated by /login", auto_error=False)
    ),
]


class User(BaseModel):
    """
    Authentication information for the current user
    """

    appuserlogin_id: int
    name: str
    roles: list[str]


def _process_auth(
    session: DBSession, cookie: LoginCookieDep, response: Response
) -> Optional[User]:
    """
    Process authorization at the beginning of (essentially) every request.
    Compare user cookie against appuserlogin_cookie and appuserlogin_nextcookie.
    If the user sent nextcookie, rotate them (assuming that from now on the old
    cookie will no longer be sent). In any case, set the cookie to be used in
    the future in the response (there was something about browsers sometimes no
    longer sending a cookie if we don't remind them with every request that
    this cookie is to be set).
    """
    stmt = select(AppUserLogin).where(
        or_(
            AppUserLogin.appuserlogin_cookie == cookie,
            AppUserLogin.appuserlogin_nextcookie == cookie,
        ),
        not_(AppUserLogin.appuserlogin_done),
    )
    login: Optional[AppUserLogin] = session.exec(stmt).one_or_none()
    if not login:
        return
    send_cookie = login.appuserlogin_nextcookie or login.appuserlogin_cookie
    user = User(
        name=login.user.appuser_name,
        roles=[
            role.appgroup_zoperole
            for role in session.exec(
                select(AppGroup)
                .join(AppPermXGroup)
                .join(AppPerm)
                .join(AppUserXPerm)
                .where(AppUserXPerm.appuserxperm_appuser_id == login.user.appuser_id)
            )
        ],
        appuserlogin_id=login.appuserlogin_id,
    )
    if cookie == login.appuserlogin_nextcookie:
        login.appuserlogin_cookie = login.appuserlogin_nextcookie
        login.appuserlogin_nextcookie = None
        # We commit here, so the authentication phase and the payload phase are
        # done in separate transactions.
        session.commit()

    response.set_cookie(
        key=COOKIE,
        value=send_cookie,
        httponly=True,
        secure=True,
        samesite="strict",
    )
    return user


Auth = Annotated[Optional[User], Depends(_process_auth)]


_F = TypeVar("F", bound=Callable[..., object])


def require_roles(*scopes: tuple[str]) -> Callable[[_F], _F]:
    """
    Decorator to check for given roles
    """

    def require_scopes(required_scopes: list[str]):
        def checker(user: Auth):
            # Check if all required scopes are present
            missing = set(required_scopes) - set(user.roles)
            if missing:
                raise HTTPException(
                    status_code=403,
                    detail=f"Missing required permissions: {', '.join(missing)}",
                )

            return True

        return checker

    dep = Depends(require_scopes(scopes))

    def decorator(func: _F) -> _F:
        sig = inspect.signature(func)

        # create a new parameter for the dependency (keyword-only)
        dep_param = inspect.Parameter(
            "scope_check",
            kind=inspect.Parameter.KEYWORD_ONLY,
            annotation=Annotated[None, dep],
        )

        # build new signature: keep original params, append dep_param
        params = list(sig.parameters.values()) + [dep_param]
        new_sig = sig.replace(parameters=params)

        @wraps(func)
        async def wrapper(*args, **kwargs):
            # remove scope_check if present before calling original func
            kwargs.pop("scope_check", None)
            return await func(*args, **kwargs)

        # attach the new signature so FastAPI sees the dependency
        wrapper.__signature__ = new_sig  # critical
        return wrapper  # type: ignore

    return decorator


class SameSitePostMiddleware(BaseHTTPMiddleware):
    """
    Rejects all POST or PUT requests that do not include a valid Sec-Fetch-Site header.
    Allowed values: "same-origin"
    """

    def __init__(self, app: ASGIApp):
        super().__init__(app)

    async def dispatch(self, request, call_next):
        if request.method in ("POST", "PUT"):
            sec_fetch_site = request.headers.get("sec-fetch-site")

            if sec_fetch_site != "same-origin":
                return JSONResponse(
                    status_code=401,
                    content={"detail": f"Unauthorized: cross-site {request.method}"},
                )

        return await call_next(request)
