import os
from typing import Annotated, Optional

from fastapi import Depends, FastAPI, Response
from fastapi.security import APIKeyCookie
from sqlalchemy import create_engine, func, not_, or_, select, update
from sqlalchemy.orm import Session

from .appuser import AppUser, AppUserLogin, Base

COOKIE = "__user_cookie"
app = FastAPI()
engine = create_engine("postgresql+psycopg://zope@/perfactema")
Base.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session
        session.commit()


LoginCookieDep = Annotated[
    str,
    Depends(
        APIKeyCookie(name=COOKIE, description="Generated by /login", auto_error=False)
    ),
]
SessionDep = Annotated[Session, Depends(get_session)]


def process_auth(
    session: SessionDep, cookie: LoginCookieDep, response: Response
) -> Optional[AppUser]:
    """
    Process authorization at the beginning of (essentially) every request.
    Compare user cookie against appuserlogin_cookie and appuserlogin_nextcookie.
    If the user sent nextcookie, rotate them (assuming that from now on the old
    cookie will no longer be sent). In any case, set the cookie to be used in
    the future in the response (there was something about browsers sometimes no
    longer sending a cookie if we don't remind them with every request that
    this cookie is to be set).
    """
    stmt = select(AppUserLogin).where(
        or_(AppUserLogin.cookie == cookie, AppUserLogin.nextcookie == cookie),
        not_(AppUserLogin.done),
    )
    login: Optional[AppUserLogin] = session.scalars(stmt).one_or_none()
    if not login:
        return
    send_cookie = login.nextcookie or login.cookie
    user = login.user
    if cookie == login.nextcookie:
        login.cookie = login.nextcookie
        login.nextcookie = None
        # We commit here, so the authentication phase and the payload phase are
        # done in separate transactions.
        session.commit()

    response.set_cookie(
        key=COOKIE,
        value=send_cookie,
        httponly=True,
        secure=True,
        samesite="strict",
    )
    return user


Auth = Annotated[Optional[AppUser], Depends(process_auth)]


@app.put("/admin/generate_user")
async def generate_user(username: str, password: str, session: SessionDep):
    """
    We would not actually allow this, at least not without first checking elevated
    permissions
    """
    user: AppUser = AppUser(
        name=username,
        password=AppUser.encrypt_pw(password),
    )
    session.add(user)
    return {"success": True}


@app.post("/admin/rotate_cookies")
async def rotate_cookies(session: SessionDep):
    """
    Something that would usually rather be done periodically and can not be triggered
    manually.
    """
    session.execute(
        update(AppUserLogin)
        .where(not_(AppUserLogin.done))
        .values(nextcookie=func.uuidv4())
    )


@app.post("/login")
async def login(username: str, password: str, session: SessionDep, response: Response):
    stmt = select(AppUser).where(AppUser.name == username)
    user: AppUser = session.scalars(stmt).one_or_none()
    if not user or not user.verify_pw(password):
        return {"success": False}
    login = AppUserLogin(
        appuser_id=user.id,
        cookie=os.urandom(32).hex(),
    )
    session.add(login)
    response.set_cookie(
        key=COOKIE,
        value=login.cookie,
        httponly=True,
        secure=True,
        samesite="strict",
    )
    return {
        "success": True,
    }


@app.post("/logout")
async def logout(
    session: SessionDep, cookie: LoginCookieDep, response: Response
) -> None:
    stmt = select(AppUserLogin).where(AppUserLogin.cookie == cookie)
    login: AppUserLogin = session.scalars(stmt).one_or_none()
    if login:
        login.done = True
    response.delete_cookie(COOKIE)


@app.get("/username")
async def username(session: SessionDep, user: Auth) -> Optional[str]:
    if user:
        return user.name
