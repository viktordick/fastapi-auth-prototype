import os
from typing import Annotated, Optional

from fastapi import Depends, FastAPI, Response
from fastapi.security import APIKeyCookie
from sqlalchemy import create_engine, not_, select
from sqlalchemy.orm import Session

from .appuser import AppUser, AppUserLogin, Base

app = FastAPI()
engine = create_engine("postgresql+psycopg://zope@/perfactema")
Base.metadata.create_all(engine)


def get_session():
    with Session(engine) as session:
        yield session
        session.commit()


LoginCookieDep = Annotated[
    str,
    Depends(
        APIKeyCookie(
            name="__user_cookie", description="Generated by /login", auto_error=False
        )
    ),
]
SessionDep = Annotated[Session, Depends(get_session)]


def process_auth(
    session: SessionDep, cookie: LoginCookieDep, response: Response
) -> Optional[AppUser]:
    """
    Process authorization at the beginning of (essentially) every request.
    Compare user cookie against appuserlogin_cookie and appuserlogin_nextcookie.
    If the user sent nextcookie,
    """
    stmt = select(AppUserLogin).where(
        AppUserLogin.cookie == cookie, not_(AppUserLogin.done)
    )
    login: Optional[AppUserLogin] = session.scalars(stmt).one_or_none()
    if login:
        return login.user


Auth = Annotated[Optional[AppUser], Depends(process_auth)]


@app.put("/admin/generate_user")
async def generate_user(username: str, password: str, session: SessionDep):
    """
    We would not actually allow this, at least not without first checking elevated
    permissions
    """
    user: AppUser = AppUser(
        name=username,
        password=AppUser.encrypt_pw(password),
    )
    session.add(user)
    return {"success": True}


@app.post("/login")
async def login(username: str, password: str, session: SessionDep, response: Response):
    stmt = select(AppUser).where(AppUser.name == username)
    user: AppUser = session.scalars(stmt).one_or_none()
    if not user or not user.verify_pw(password):
        return {"success": False}
    login = AppUserLogin(
        appuser_id=user.id,
        cookie=os.urandom(32).hex(),
    )
    session.add(login)
    response.set_cookie(
        key="__login", value=login.cookie, httponly=True, secure=True, samesite="strict"
    )
    return {
        "success": True,
    }


@app.post("/logout")
async def logout(
    session: SessionDep, cookie: LoginCookieDep, response: Response
) -> None:
    stmt = select(AppUserLogin).where(AppUserLogin.cookie == cookie)
    login: AppUserLogin = session.scalars(stmt).one_or_none()
    if login:
        login.done = True
    response.delete_cookie("__login")


@app.get("/username")
async def username(session: SessionDep, user: UserDep) -> Optional[str]:
    if user:
        return user.name
